/*-
 * DBSQL - A SQL database engine.
 *
 * Copyright (C) 2007  The DBSQL Group, Inc. - All rights reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * http://creativecommons.org/licenses/GPL/2.0/
 *
 * $Id: vdbe_int.h 7 2007-02-03 13:34:17Z gburd $
 */

#ifndef	_VDBE_INT_H_
#define	_VDBE_INT_H_


#if defined(__cplusplus)
extern "C" {
#endif

/*
 * This is the header file for information that is private to the
 * VDBE.
 */

/*
 * When converting from the native format to the key format and back
 * again, in addition to changing the byte order we invert the high-order
 * bit of the most significant byte.  This causes negative numbers to
 * sort before positive numbers in the memcmp() function.
 */
#define KEY_TO_INT(X)   (__vdbe_byte_swap(X) ^ 0x80000000)
#define INT_TO_KEY(X)   (__vdbe_byte_swap((X) ^ 0x80000000))

/*
 * The makefile scans this source file and creates the following
 * array of string constants which are the names of all VDBE opcodes.
 * This array is defined in a separate source code file named opcode.c
 * which is automatically generated by the makefile.
 */
extern char *__opcode_names[];

/*
 * Boolean values
 */
typedef unsigned char bool_t;

/*
 * The cursor can seek to a btree entry with a particular key, or
 * loop over all entries of the btree.  You can also insert new
 * entries or retrieve the key or data from the entry that the cursor
 * is currently pointing to.
 * 
 * Every cursor that the virtual machine has open is represented by an
 * instance of the following structure.
 *
 * If the cursor_t.isTriggerRow flag is set it means that this cursor is
 * really a single row that represents the NEW or OLD pseudo-table of
 * a row trigger.  The data for the row is stored in cursor_t.pData and
 * the rowid is in cursor_t.iKey.
 */
struct cursor {
	sm_cursor_t *pCursor; /* The cursor structure of the backend */
	int lastRecno;        /* Last recno from a Next or NextIdx operation */
	int nextRowid;        /* Next rowid returned by OP_NewRowid */
	bool_t recnoIsValid;  /* True if lastRecno is valid */
	bool_t keyAsData;     /* The OP_Column command works on key instead
				 of data */
	bool_t atFirst;       /* True if pointing to first entry */
	bool_t useRandomRowid;/* Generate new record numbers semi-randomly */
	bool_t nullRow;       /* True if pointing to a row with no data */
	bool_t nextRowidValid;/* True if the nextRowid field is valid */
	bool_t pseudoTable;   /* This is a NEW or OLD pseudo-tables of a
				 trigger */
	bool_t deferredMoveto;/* A call to __sm_moveto() is needed */
	int movetoTarget;     /* Argument to the deferred __sm_moveto() */
	sm_t *pBt;            /* Separate database holding temporary tables */
	int nData;            /* Number of bytes in pData */
	char *pData;          /* Data for a NEW or OLD pseudo-table */
	int iKey;             /* Key for the NEW or OLD pseudo-table row */
};

/*
 * A sorter builds a list of elements to be sorted.  Each element of
 * the list is an instance of the following structure.
 */
typedef struct sorter sorter_t;
struct sorter {
  int nKey;           /* Number of bytes in the key */
  char *zKey;         /* The key by which we will sort */
  int nData;          /* Number of bytes in the data */
  char *pData;        /* The data associated with this key */
  sorter_t *pNext;    /* Next in the list */
};

/* 
 * Number of buckets used for merge-sort.  
 */
#define NSORT 30

/*
 * Number of bytes of string storage space available to each stack
 * layer without having to malloc.  NBFS is short for Number of Bytes
 * For Strings.
 */
#define NBFS 32

/*
 * A single level of the stack or a single memory cell
 * is an instance of the following structure. 
 */
struct mem {
	int i;              /* Integer value */
	int n;              /* Number of characters in string value,
			       including '\0' */
	int flags;          /* Some combination of MEM_Null, MEM_Str,
			       MEM_Dyn, etc. */
/* Allowed values for mem_t.flags */
#define MEM_Null      0x0001   /* Value is NULL */
#define MEM_Str       0x0002   /* Value is a string */
#define MEM_Int       0x0004   /* Value is an integer */
#define MEM_Real      0x0008   /* Value is a real number */
#define MEM_Dyn       0x0010   /* Need to call __os_free() on mem_t.z */
#define MEM_Static    0x0020   /* mem_t.z points to a static string */
#define MEM_Ephem     0x0040   /* mem_t.z points to an ephemeral string */
#define MEM_Short     0x0080   /* mem_t.z points to mem_t.zShort */
/*
 * The following MEM_ value appears only in AggElem.aMem.s.flag fields.
 * It indicates that the corresponding AggElem.aMem.z points to a
 * aggregate function context that needs to be finalized.
 */
#define MEM_AggCtx    0x0100   /* mem_t.z points to an agg function context */
	double r;           /* Real value */
	char *z;            /* String value */
	char zShort[NBFS];  /* Space for short strings */
};
typedef struct mem mem_t;


/*
 * The "context" argument for a installable function.  A pointer to an
 * instance of this structure is the first argument to the routines used
 * implement the SQL functions.
 *
 * There is a typedef for this structure in dbsql.h.  So all routines,
 * even the public interface, can use a pointer to this structure.
 * But this file is the only place where the internal details of this
 * structure are known.
 *
 * This structure is defined inside of vdbe.c because it uses substructures
 * (mem_t) which are only defined there.
 */
struct __dbsql_func {
	func_def_t *pFunc;    /* Pointer to function information.
				 !!! MUST BE FIRST IN STRUCT */
	mem_t s;              /* The return value is stored here */
	void *pAgg;           /* Aggregate context */
	u_int8_t isError;     /* Set to true for an error */
	u_int8_t isStep;      /* Current in the step function */
	int cnt;              /* Number of times that the step function
				 has been called */
};

/*
 * An agg_t structure describes an Aggregator.  Each agg_t consists of
 * zero or more Aggregator elements (agg_elem_t).  Each agg_elem_t contains
 * a key and one or more values.  The values are used in processing
 * aggregate functions in a SELECT.  The key is used to implement
 * the GROUP BY clause of a select.
 */
struct agg {
	int nMem;             /* Number of values stored in each AggElem */
	agg_elem_t *pCurrent; /* The AggElem currently in focus */
	hash_ele_t *pSearch;  /* The hash element for pCurrent */
	hash_t hash;          /* Hash table of all aggregate elements */
	func_def_t **apFunc;  /* Information about aggregate functions */
};
struct agg_elem {
	char *zKey;           /* The key to this AggElem */
	int nKey;             /* Number of bytes in the key, including '\0'
				 at end */
	mem_t aMem[1];        /* The values for this AggElem */
};

/*
 * A Set structure is used for quick testing to see if a value
 * is part of a small set.  Sets are used to implement code like
 * this:
 *            x.y IN ('hi','hoo','hum')
 */
typedef struct set set_t;
struct set {
	hash_t hash;             /* A set is just a hash table */
	hash_ele_t *prev;        /* Previously accessed hash elemen */
};

/*
 * A keylist_t is a bunch of keys into a table.  The keylist can
 * grow without bound.  The keylist stores the ROWIDs of database
 * records that need to be deleted or updated.
 */
struct keylist {
	int nKey;             /* Number of slots in aKey[] */
	int nUsed;            /* Next unwritten slot in aKey[] */
	int nRead;            /* Next unread slot in aKey[] */
	keylist_t *pNext;     /* Next block of keys */
	int aKey[1];          /* One or more keys.  Extra space allocated
				 as needed */
};

/*
 * An instance of the virtual machine.  This structure contains the complete
 * state of the virtual machine.
 *
 * The "sqlvm_t" structure pointer that is returned by dbsql_compile()
 * is really a pointer to an instance of this structure.
 */
struct vdbe {
	DBSQL *db;            /* The whole database */
	vdbe_t *pPrev,*pNext; /* Linked list of VDBEs with the same
				 vdbe_t.db */
	FILE *trace;          /* Write an execution trace here, if not NULL */
	int nOp;              /* Number of instructions in the program */
	int nOpAlloc;         /* Number of slots allocated for aOp[] */
	vdbe_op_t *aOp;       /* Space to hold the virtual machine's program */
	int nLabel;           /* Number of labels used */
	int nLabelAlloc;      /* Number of slots allocated in aLabel[] */
	int *aLabel;          /* Space to hold the labels */
	mem_t *aStack;        /* The operand stack, except string values */
	mem_t *pTos;          /* Top entry in the operand stack */
	char **zArgv;         /* Text values used by the callback */
	char **azColName;     /* Becomes the 4th parameter to callbacks */
	int nCursor;          /* Number of slots in aCsr[] */
	cursor_t *aCsr;       /* One element of this array for each open
				 cursor */
	sorter_t *pSort;      /* A linked list of objects to be sorted */
	FILE *pFile;          /* At most one open file handler */
	int nField;           /* Number of file fields */
	char **azField;       /* Data for each file field */
	int nVar;             /* Number of entries in azVariable[] */
	char **azVar;         /* Values for the OP_Variable opcode */
	int *anVar;           /* Length of each value in azVariable[] */
	u_int8_t *abVar;      /* TRUE if azVariable[i] needs to be
				 __os_free()ed */
	char *zLine;          /* A single line from the input file */
	int nLineAlloc;       /* Number of spaces allocated for zLine */
	int magic;            /* Magic number for sanity checking */
	int nMem;             /* Number of memory locations currently
				 allocated */
	mem_t *aMem;          /* The memory locations */
	agg_t agg;            /* Aggregate information */
	int nSet;             /* Number of sets allocated */
	set_t *aSet;          /* An array of sets */
	int nCallback;        /* Number of callbacks invoked so far */
	keylist_t *pList;     /* A list of ROWIDs */
	int keylistStackDepth;  /* The size of the "keylist" stack */
	keylist_t **keylistStack; /* The stack used by opcodes ListPush &
				     ListPop */
	int pc;               /* The program counter */
	int rc;               /* Value to return */
	unsigned uniqueCnt;   /* Used by OP_MakeRecord when P2!=0 */
	int errorAction;      /* Recovery action to do in case of an error */
	int undoTransOnError; /* If error, either ROLLBACK or COMMIT */
	int inTempTrans;      /* True if temp database is transactioned */
	int returnStack[100]; /* Return address stack for OP_Gosub &
				 OP_Return */
	int returnDepth;      /* Next unused element in returnStack[] */
	int nResColumn;       /* Number of columns in one row of the result
				 set */
	char **azResColumn;   /* Values for one row of result */ 
	int (*xCallback)(void*,int,char**,char**); /* Callback for SELECT
						      results */
	void *pCbArg;         /* First argument to xCallback() */
	int popStack;         /* Pop the stack this much on entry to
				 __vdbe_exec() */
	char *zErrMsg;        /* Error message written here */
	u_int8_t explain;     /* True if EXPLAIN present on SQL command */
#ifdef CONFIG_TEST
	u_int32_t search_count; /* The number of OP_MoveTo or the OP_Next
				   executed */
#endif
};

/*
** The following are allowed values for vdbe_t.magic
*/
#define VDBE_MAGIC_INIT     0x26bceaa5    /* Building a VDBE program */
#define VDBE_MAGIC_RUN      0xbdf20da3    /* VDBE is ready to execute */
#define VDBE_MAGIC_HALT     0x519c2973    /* VDBE has completed execution */
#define VDBE_MAGIC_DEAD     0xb606c3c8    /* The VDBE has been deallocated */

#if defined(__cplusplus)
}
#endif
#endif /* !_VDBE_INT_H_ */
